#  每天一积累

##  2021/3/7 什么是B树？为啥文件索引要用B树而不用二叉查找树？

B树就是一棵多叉查找树，对于一棵 m 阶的 B 树具有如下特性：

1、根节点至少有两个孩子。

2、每个中间节点都包含 k - 1 个元素和 k 个孩子，其中 m/2 <= k <= m。

3、每一个叶子节点都包含 k - 1 个元素，其中 m/2 <= k <= m。

4、所有的叶子节点都位于同一侧。

5、每个节点中的元素从小到大排列，节点当中的 k - 1 个元素正好是 k 个孩子包含的元素的值域划分。

![1615118447212](C:\Users\a\AppData\Roaming\Typora\typora-user-images\1615118447212.png)

​      因为二叉查找树节点在内存中是不连续的，如果单单从比较次数来看，B树和二叉查找树有可能比较次数相同，但是从性能上来说，数据都存放在磁盘里面，所以我们要考虑到磁盘的寻址次数。 我们知道，在把磁盘里的数据加载到内存中的时候，是以**页**为单位来加载的，而我们也知道，**节点与节点之间的数据是不连续的**，所以不同的节点，很有可能分布在不同的**磁盘页**中 。

​      还有在内存的运算速度是非常快的，至少比磁盘的寻址加载速度，快了几百倍，而我们进行数值比较的时候，是在内存中进行的，虽然 B 树的比较次数可能比二叉查找树多，但是**磁盘操作次数少**，所以总体来说，还是 B 树快的多，这也是为什么我们用使用 B 树来存储的原因。 

   最后： B 树除了会用在少部分的文件索引（数据库索引）外，应用的最多的就是**文件系统**了。  大部分文件索引或者数据库索引都是用 **B+ 树**的，而只有小部分才用 B 树 。

##  2021/3/8 为什么MySQL数据库要用B+树存储索引？

B+树是在B树的基础上进行改造的，它的数据都在叶子结点，同时叶子结点之间还加了指针形成链表。

![1615214773477](C:\Users\a\AppData\Roaming\Typora\typora-user-images\1615214773477.png)

**为什么要这样设计呢？**因为这样设计，数据就全在叶子结点上。

![1615215536366](C:\Users\a\AppData\Roaming\Typora\typora-user-images\1615215536366.png)

如果只选一个数据，那么hash比b+树快。但是数据库中经常会选择多条，这时候由于B+树索引有序，并且又要链表相连，它的查询效率就比hash快很多。而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。 

## 2021/3/9 有了二叉查找树、平衡树为啥还需要红黑树？

二叉查找树的特点： 就是**左子树的节点值比父亲节点小，而右子树的节点值比父亲节点** 。![1615301466007](F:\桌面文件\wlyPPT\markdown\每天一积累.assets\1615301466007.png)

 基于二叉查找树的这种特点，我们在查找某个节点的时候，可以采取类似于**二分查找**的思想，快速找到某个节点。n 个节点的二叉查找树，正常的情况下，查找的时间复杂度为 O（logn）。 

 之所以说是**正常情况下**，是因为二叉查找树有可能出现一种极端的情况，例如 ![1615301487483](F:\桌面文件\wlyPPT\markdown\每天一积累.assets\1615301487483.png)

 这种情况也是满足**二叉查找树**的条件，然而，此时的二叉查找树已经近似退化为一条链表，这样的二叉查找树的查找时间复杂度顿时变成了 O(n)，可想而知，我们必须不能让这种情况发生，为了解决这个问题，于是我们引申出了**平衡二叉树**。 

平衡二叉树就是为了解决二叉查找树退化成一条链表而诞生的，它的特点是：

1、具有二叉查找树的全部特性。

2、每个节点的左子树和右子树的高度差至多等于1。

<img src="F:\桌面文件\wlyPPT\markdown\每天一积累.assets\1615301633475.png" alt="1615301633475" style="zoom:67%;" />

 对于图二，因为节点9的左孩子高度为2，而右孩子高度为0。他们之间的差值超过1了。  平衡树基于这种特点就可以保证不会出现大量节点偏向于一边的情况了。 

 于是，通过平衡树，我们解决了二叉查找树的缺点。对于有 n 个节点的平衡树，最坏的查找时间复杂度也为 O(logn)。 而不会退化成一条链表。



**为什么有了平衡树还需要红黑树呢**？

虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求**每个节点的左子树和右子树的高度差至多等于1**，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过**左旋**和**右旋**来进行调整，使之再次成为一颗符合要求的平衡树。

显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了**红黑树**，红黑树具有如下特点：

**1、具有二叉查找树的特点。**

**2、根节点是黑色的；**

**3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。**

**4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。**

**5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。**

 正是由于红黑树的这种特点，使得它能够在最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。 

 不过，与平衡树不同的是，红黑树在插入、删除等操作，**不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整**，这也是我们为什么大多数情况下使用红黑树的原因。 

 单单在查找方面的效率的话，平衡树比红黑树快。 



总结： 平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。 



##  2021/3/10关于三次握手与四次挥手面试官想考我们什么？

**三次握手**：可以验证客户端和服务器双方的发送和接收功能是否正常

第一次握手： 客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。   

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

 因此，需要三次握手才能确认双方的接收与发送能力是否正常。 

更加详细的话：

1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 **ISN(c)**。此时客户端处于 **SYN_Send** 状态。

2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 **SYN_REVD** 的状态。

3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 **establised**（**以连接**） 状态。

4、服务器收到 ACK 报文之后，也处于 **establised 状态**，此时，双方以建立起了链接。![1615388142301](F:\桌面文件\wlyPPT\markdown\每天一积累.assets\1615388142301.png)

**三次握手的作用**

三次握手的作用也是有好多的，多记住几个，保证不亏。例如：

1、确认双方的接受能力、发送能力是否正常。

2、指定自己的初始化序列号，为后面的可靠传送做准备。

3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。



**关于三次握手的问题？**

**1、（ISN）是固定的吗**

三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

**2、什么是半连接队列**

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

![1615388245223](F:\桌面文件\wlyPPT\markdown\每天一积累.assets\1615388245223.png)

**3、三次握手过程中可以携带数据吗**

很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。

而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。



**四次挥手**

刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于**CLOSED_WAIT1**状态。

2、第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 **CLOSE_WAIT2**状态。

这时客户端已经确定自己不需要再发送数据给服务器了，但这个时候服务器可能还有没发完的数据给客户端，所以服务器现在还是可以发送数据给客户端的，如果服务器已经没有数据发送的时候，就进行第三次挥手。

 3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 **LAST_ACK** 的状态。 

 4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 **TIME_WAIT** 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态 

 5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 

![1615388911740](F:\桌面文件\wlyPPT\markdown\每天一积累.assets\1615388911740.png)



这里特别需要主要的就是**TIME_WAIT**这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。

![1615388957805](F:\桌面文件\wlyPPT\markdown\每天一积累.assets\1615388957805.png)

##  2021/3/11 堆排序

代码：

 

```java
public class HeapSort {
  */**
  \*  下沉操作，执行删除操作相当于把最后
  \*  \* 一个元素赋给根元素之后，然后对根元素执行下沉操作
  \* @param arr
  \* @param parent 要下沉元素的下标
  \* @param length 数组长度
  \*/*
  public static int[] downAdjust(int[] arr, int parent, int length) {
    *//临时保证要下沉的元素*
    int temp = arr[parent];
    *//定位左孩子节点位置*
    int child = 2 * parent + 1;
    *//开始下沉*
    while (child < length) {
      *//如果右孩子节点比左孩子小，则定位到右孩子*
      if (child + 1 < length && arr[child] > arr[child + 1]) {
        child++;
      }
      *//如果父节点比孩子节点小或等于，则下沉结束*
      if (temp <= arr[child])
        break;
      *//单向赋值*
      arr[parent] = arr[child];
      parent = child;
      child = 2 * parent + 1;
    }
    arr[parent] = temp;
    return arr;
  }

  *//堆排序*
  public static int[] heapSort(int[] arr, int length) {
    *//构建二叉堆*
    for (int i = (length - 2) / 2; i >= 0; i--) {
      arr = downAdjust(arr, i, length);
    }
    *//进行堆排序*
    for (int i = length - 1; i >= 1; i--) {
      *//把堆顶的元素与最后一个元素交换*
      int temp = arr[i];
      arr[i] = arr[0];
      arr[0] = temp;
      *//下沉调整*
      arr = downAdjust(arr, 0, i);
    }
    return arr;
  }
  *//测试*
  public static void main(String[] args) {
    int[] arr = new int[]{1, 3, 5,2, 0,10,6};
    System.out.println(Arrays.toString(arr));
    arr = heapSort(arr, arr.length);
    System.out.println(Arrays.toString(arr));
  }
} 
```

如果用一个辅助数组来进行堆排序，那么每次从堆顶删除元素，最后辅助数组就是一个从小到大的数组。

##  PS c++头文件

```c++
#include<bits/stdc++.h>//包含所有头文件
using namespace std;

int main(){

    return 0;

}
//整形转换字符串
	cin>>n;
    stringstream ss;
    ss << n;
    string str = ss.str();

//cin>>遇到回车或者空格会停止
要想获取一行字母包括空格之类 需要用
    char s[10000];
    cin.getline(s, 10000);
	//用c语言的同学试试这个fgets(a, 10000, stdin); 
```

##  2021/3/12 求 x 的 n 次方、搜索旋转排序数组

**1.求x的n次方**

快速幂方法：![1615561459564](每天一积累.assets/1615561459564.png)

```c
 int pow(int x, int n){
  int res = 1;
  while(n > 0){
    if(n % 2 == 1){
      res *= x;
    }
    n >> 1;
    x = x * x;
  }
} 
```

**2.搜索旋转排序数组**

![1615562683199](每天一积累.assets/1615562683199.png)

```c++
 int rotatedBinarySearch(int[] arr, int target){
  // 最左侧元素下标
  int left = 0;
  // 最右侧元素下标
  int right = arr.length - 1;
  while(left <= right){
    // 中间元素下标
    int mid = left + (right - left) / 2;
    if(arr[mid] == target){
      return mid;
    }

​    // 情况1：如果中间元素在旋转点左侧
​    if(arr[mid] >= arr[left]){
​      //target 如果位于中间元素的左侧
​      if(arr[mid] > target && target >= arr[left]){
​        right = mid - 1;
​      }else{
​        left = mid + 1;
​      }
​    }
​    // 情况2：中间元素在旋转点的右侧
​    else{
      // target 如果位于中间元素的右侧
​      if(arr[mid] < target && target <= arr[right]){
​        left = mid + 1;
​      }else{
​        right = mid - 1;
​      }
​    }
  }
  return -1;
} 
```

## 2021/3/13 动态规划--简单-- **爬楼梯** 

题目： **假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？** 

第n阶楼梯=n-1阶方法+n-2阶方法  因为一次可以爬1或者爬2

```c
dp[n] = dp[n-1]+dp[n-2]
```

![1615650004492](每天一积累.assets/1615650004492.png)

```c++
fun dbClimbStairs(int n){
   if(n == 1){
      return 1;
   }
   int dp[n+1];
   dp[1] = 1;
   dp[2] = 2;//一次爬1 一次爬2 
   for(int i = 3;i <= n;i++){
    dp[i] = dp[i-1]+dp[i-2];
   }
   return dp[n];
}
```

##  2021/3/14 <面试>一条sql执行很慢的原因

一个 SQL 执行的很慢，我们要分两种情况讨论：

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

  因为每次执行数据库crud操作的时候，数据都会存放在redo log里面，等到数据库空闲的时候，才会把这些数据存放在持久化的磁盘中。 不过，redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，**就会导致我们平时正常的SQL语句突然执行的很慢**，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。 

(2)、执行的时候，遇到锁，如表锁、行锁。

判断是否等待锁，可以用 show processlist的命令查看状态。

2、这条 SQL 语句一直执行的很慢，则有如下原因。

**1.**没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

**2.**或者字段有索引，但却没有用索引。如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种字段上有索引，但由于自己的疏忽，导致系统没有使用索引的情况了。

**3.**函数操作导致没有用上索引。

 **所以呢**，一条语句执行都很慢的时候，可能是该语句没有用上索引了，不过具体是啥原因导致没有用上索引的呢，你就要会分析了，我上面列举的三个原因，应该是出现的比较多的吧。 

(2)、数据库选错了索引。

**为什么会这样呢？**

其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。

如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c < and c < 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。

**所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？**

判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。

那么问题来了，**系统是怎么预测判断的呢？**这里我给你讲下系统是怎么判断的吧，虽然这个时候我已经写到脖子有点酸了。

系统是通过**索引的区分度**来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为**基数**，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 < c and c < 10000 这个条件的行数越少。

所以呢，一个索引的基数越大，意味着走索引查询越有优势。

**那么问题来了，怎么知道这个索引的基数呢？**

系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过**采样**的方式，来预测索引的基数的。

**扯了这么多，重点的来了**，居然是采样，那就有可能出现**失误**的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。**然后就呵呵，系统就不走 c 索引了，直接走全部扫描了**。

所以呢，说了这么多，得出结论：**由于统计的失误，导致系统没有走索引，而是走了全表扫描**，而这，也是导致我们 SQL 语句执行的很慢的原因。



##  2021/3/15  **L1-003 个位数统计 (15 分)** 

![1615819973473](每天一积累.assets/1615819973473.png)

 输入的数据可以定义为字符串，这样子就不需要考虑位数的大小了。

str[i]-'0'=等于数字 例如 '3'-'0'=3 他们的ASCII码相差为3；

代码

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
	int num[10]={0};
	string n;
	cin>>n;
    int len = n.length();
    for(int i = 0;i < len;i++){
    	num[n[i]-'0']++;
	}
	for(int i = 0;i < 10;i++){
		if(num[i])
			cout<<i<<":"<<num[i]<<endl;
	}
	return 0;
} 
```

##  2021/3/15 刚开机的电脑如何获取ip地址？

**PS**：0.0.0.0代表默认路由或者代表主机还没分配ip地址

默认路由的用处： 当一个路由器要发送路由表中无法查询的包时，如果设置了全零网络的路由时，我们就可以把这个包丢给全零网络的路由。 

当电脑开机的时候，电脑ip地址是0.0.0.0，这时要请求DHCP服务器获取一个ip地址才能进行网上冲浪，但是电脑不知道dhcp服务器的ip地址，所以他只能向本网络的所有主机进行广播，广播所携带的数据包内容包括源mac地址，源ip地址0.0.0.0，目的地址255.255.255.255（告诉路由器向所有主机发送数据包),当该网络下的主机收到这一条数据报的时候， 会进行判断这个广播报文是否是发给自己的，如果是发给自己的，则进行处理，否则就把这个广播报文丢弃。 但是所有的主机ip地址都不是255.255.255.255，但是dhcp服务器比较特殊，他发现数据报的源ip地址是0.0.0.0，所以就知道这个主机是没有分配ip地址的，所以dhcp就发送一个数据报，包括一个分配未使用的ip地址给到新开机的电脑（新开机的电脑在未分配ip地址前，服务器是如何找到这个新开机的电脑呢？是因为根据mac地址来寻找，mac地址是唯一的),然后在服务器标记这个分配的ip地址被使用中。



##  2021/3/16 进程之间的通信方式有哪些？

1、管道
我们来看一条 Linux 的语句

netstat -tulnp | grep 8080
学过 Linux 命名的估计都懂这条语句的含义，其中”|“是管道的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种管道来进行通信了，并且我们可以知道这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。

并且这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。

居然有匿名管道，那也意味着有命名管道，下面我们来创建一个命名管道。

mkfifo  test
这条命令创建了一个名字为 test 的命名管道。

接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。

echo "this is a pipe" > test   // 写数据
这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取

cat < test  // 读数据
我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。

从上面的例子可以看出，管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。

这种通信方式有什么缺点呢？显然，这种通信方式效率低下，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。

所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。

2、消息队列
那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？

答是可以的，我们可以用消息队列的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的
消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于缓存吧。

这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味发送消息（拷贝）这个过程需要花很多时间来读内存。

哪有没有什么解决方案呢？答是有的，请继续往下看。

3、共享内存
共享内存这个通信方式就可以很好着解决拷贝所消耗的时间了。

这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？

我们都知道，系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。

4、信号量
共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的线程安全问题。如何解决这个问题？这个时候我们的信号量就上场了。

信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。

5、Socket
上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？

答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。

总结
所以，进程之间的通信方式有：

1、管道

管道只能单方面的传输，效率低下，管道的内容只有被取出去，这条命令才停止，不然会一直停留在这条命令中。不适合频繁通信。

2、消息队列

双方进程进行通信，把各自的内容放到消息队列里面，需要就去取，如果进程存放的内容过大，导致消息队列内存溢出，又或者频繁通信的话，消息队列就不适合了。因为进程取内容是要花掉时间和资源是拷贝所需的内容的。

3、共享内存

共享内存可以很好避免拷贝内存所花的时间，因为 系统加载一个进程的时候，分配给进程的内存并不是**实际物理内存**，而是**虚拟内存空间**。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了**内存共享**机制了。 

4、信号量

 共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的**线程安全**问题。如何解决这个问题？这个时候我们的**信号量**就上场了。 

5、Socket

##  2021/3/17  String 为什么设置为不可变？

* 为了实现字符串常量池(只有当字符是不可变的，字符串池才有可能实现) （为什么字符串池才能出现？因为如果字符串池的数据一直变化，那么对象对它的引用就会改变，不能从字符串池选择固定的字符串给到对象）
* 为了线程安全(字符串自己便是线程安全的) 
* 为了保证同一个对象调用 hashCode() 都产生相同的值，String 设置为不可变可以对这个条件有很好的支持，这也是 Map 类的 key 使用 String 的原因。
* ![1616513288413](每天一积累.assets/1616513288413.png)

如何通过反射来修改内部属性 -- 获取class类对象 再获得实例---改变属性

##  2021/3/18 HTTP状态码

1xx :指示信息–表示请求已接收,继续处理
2xx :成功–表示请求已被成功接收、理解、接受
3xx :重定向–要完成请求必须进行更进一步的操作
4xx :**客户端错误**–请求有语法错误或请求无法实现
5xx :**服务器端错误**–服务器未能实现合法的请求

----------------------

##  2021/3/19 String StringBuffer 和 StringBuilder 的区别是什么?

**线程安全**

 `StringBuilder`是线程不安全的，效率较高；而`StringBuffer`是线程安全的，效率较低。

**性能**

StringBuilder每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**数据可变和不可变**

1. `String`的值不可变的。
2. `StringBuffer`和`StringBuilder`的值是可变的，底层使用的是可变字符数组：`char[] value;`

**使用场景**

* 如果需要操作少量的数据用 String
* 单线程操作字符串缓冲区的情况下操作大量数据使用 StringBuilder  
* 多线程操作字符串缓冲区 下操作大量数据使用 StringBuffer 

## 2021/3/20 java基础篇

### java有哪些特点

- 并发性的：你可以在其中执行许多语句，而不必一次执行它
- 面向对象的：基于类，一切都是对象的编程语言
- 独立性的：支持一次编写，到处运行的独立编程语言，即编译后的代码可以在支持java的所有平台上运行



### java的特性

- `简单`，Java 会让你的工作变得更加轻松，使你把关注点放在主要业务逻辑上，而不必关心指针、运算符重载、内存回收等与主要业务无关的功能。
- `便携性`，Java 是平台无关性的，这意味着在一个平台上编写的任何应用程序都可以轻松移植到另一个平台上。
- `安全性`， 编译后会将所有的代码转换为字节码，人类无法读取。它使开发无病毒，无篡改的系统/应用成为可能。
- `动态性`，它具有适应不断变化的环境的能力，它能够支持动态内存分配，从而减少了内存浪费，提高了应用程序的性能。
- `分布式`，Java 提供的功能有助于创建分布式应用。使用`远程方法调用（RMI）`，程序可以通过网络调用另一个程序的方法并获取输出。您可以通过从互联网上的任何计算机上调用方法来访问文件。这是革命性的一个特点，对于当今的互联网来说太重要了。
- `健壮性`，Java 有强大的内存管理功能，在编译和运行时检查代码，它有助于消除错误。
- `高性能`，Java 最黑的科技就是字节码编程，Java 代码编译成的字节码可以轻松转换为本地机器代码。通过 JIT 即时编译器来实现高性能。
- `解释性`，Java 被编译成字节码，由 Java 运行时环境解释。
- `多线程性`，Java支持多个执行线程（也称为轻量级进程），包括一组同步原语。这使得使用线程编程更加容易，Java 通过管程模型来实现线程安全性。

### 值传递和引用传递的区别

要想真正理解的话，可以参考这篇文章 ：https://www.zhihu.com/question/31203609

简单理解的话就是

`值传递`是指在调用函数时将实际参数复制一份到函数中，这样的话如果函数对其传递过来的形式参数进行修改，将不会影响到实际参数

`引用传递` 是指在调用函数时将对象的地址直接传递到函数中，如果在对形式参数进行修改，将影响到实际参数的值。

---

![1616256227518](每天一积累.assets/1616256227518.png)

----

###  2021/3/21 == 和 equals 区别是什么

![1616338351122](每天一积累.assets/1616338351122.png)

![1616338360868](每天一积累.assets/1616338360868.png)

equals 用作对象之间的比较具有如下特性

- `自反性`：对于任何非空引用 x 来说，x.equals(x) 应该返回 true。
- `对称性`：对于任何非空引用 x 和 y 来说，若x.equals（y）为 true，则y.equals（x）也为 true。
- `传递性`：对于任何非空引用的值来说，有三个值，x、y 和 z，如果x.equals(y) 返回true，y.equals(z) 返回true，那么x.equals(z) 也应该返回true。
- `一致性`：对于任何非空引用 x 和 y 来说，如果 x.equals(y) 相等的话，那么它们必须始终相等。
- `非空性`：对于任何非空引用的值 x 来说，x.equals(null) 必须返回 false。

###  String中的equals是如何重写的

String 代表的是 Java 中的`字符串`，String 类比较特殊，它整个类都是被 `final` 修饰的，也就是说，String 不能被任何类继承，任何 `修改` String 字符串的方法都是创建了一个新的字符串。

equals 方法是 Object 类定义的方法，Object 是所有类的父类，当然也包括 String，String 重写了 `equals` 方法，下面我们来看看是怎么重写的

![1616338750155](每天一积累.assets/1616338750155.png)

- 首先会判断要比较的两个字符串它们的`引用`是否相等。如果引用相等的话，直接返回 true ，不相等的话继续下面的判断
- 然后再判断被比较的对象是否是 String 的实例，如果不是的话直接返回 false，如果是的话，再比较两个字符串的长度是否相等，如果长度不想等的话也就没有比较的必要了；长度如果相同，会比较字符串中的每个 `字符` 是否相等，一旦有一个字符不相等，就会直接返回 false。

![1616338939103](每天一积累.assets/1616338939103.png)

![1616338948880](每天一积累.assets/1616338948880.png)

###  2021/3/22为什么重写 equals 方法必须重写 hashcode 方法

equals 方法和 hashCode 都是 Object 中定义的方法，它们经常被一起重写。

equals 方法是用来比较对象大小是否相等的方法，hashcode 方法是用来判断每个对象 hash 值的一种方法。如果只重写 equals 方法而不重写 hashcode 方法，很可能会造成两个不同的对象，它们的 hashcode 也相等，造成冲突。比如

![1616428594555](每天一积累.assets/1616428594555.png)

总结起来就是

- 如果在 Java 运行期间对同一个对象调用 hashCode 方法后，无论调用多少次，都应该返回相同的 hashCode，但是在不同的 Java 程序中，执行 hashCode 方法返回的值可能不一致。
- 如果两个对象的 equals 相等，那么 hashCode 必须相同
- 如果两个对象 equals 不相等，那么 hashCode 也有可能相同，所以需要重写 hashCode 方法，因为你不知道 hashCode 的底层构造（反正我是不知道，有大牛可以传授传授），所以你需要重写 hashCode 方法，来为不同的对象生成不同的 hashCode 值，这样能够提高不同对象的访问速度。
- hashCode 通常是将地址转换为整数来实现的。

###  String s1 = new String("abc") 在内存中创建了几个对象

 一个或者两个，String s1 是声明了一个 String 类型的 s1 变量，它不是对象。使用 `new` 关键字会在堆中创建一个对象，另外一个对象是 `abc` ，它会在常量池中创建，所以一共创建了两个对象；如果 abc 在常量池中已经存在的话，那么就会创建一个对象。 

###  2021/3/23 static 关键字是干什么用的？谈谈你的理解

static 是 Java 中非常重要的关键字，static 表示的概念是 `静态的`，在 Java 中，static 主要用来

- 修饰变量，static 修饰的变量称为`静态变量`、也称为`类变量`，类变量属于类所有，对于不同的类来说，static 变量只有一份，static 修饰的变量位于方法区中；static 修饰的变量能够直接通过 类名.变量名 来进行访问，不用通过实例化类再进行使用。
- 修饰方法，static 修饰的方法被称为`静态方法`，静态方法能够直接通过 类名.方法名 来使用，在静态方法内部不能使用非静态属性和方法。因为静态方法是不用实例化就能调用的，如果方法包含了需要实例化的方法或属性的话就会冲突、出错。
- static 可以修饰代码块，主要分为两种，一种直接定义在类中，使用 `static{}`，这种被称为`静态代码块`，一种是在类中定义`静态内部类`，使用 `static class xxx` 来进行定义。
- static 可以用于静态导包，通过使用 `import static xxx` 来实现，这种方式一般不推荐使用
- static 可以和单例模式一起使用，通过双重检查锁来实现线程安全的单例模式。

###  final 关键字是干什么用的？谈谈你的理解

final 是 Java 中的关键字，它表示的意思是 `不可变的`，在 Java 中，final 主要用来

- 修饰类，final 修饰的类不能被继承，不能被继承的意思就是不能使用 `extends` 来继承被 final 修饰的类。
- 修饰变量，final 修饰的变量不能被改写，不能被改写的意思有两种，对于基本数据类型来说，**final 修饰的变量，其值不能被改变，final 修饰的对象，对象的引用不能被改变，但是对象内部的属性可以被修改**。final 修饰的变量在某种程度上起到了`不可变`的效果，所以，可以用来保护只读数据，尤其是在并发编程中，因为明确的不能再为 final 变量进行赋值，有利于减少额外的同步开销。
- 修饰方法，final 修饰的方法不能被重写。
- final 修饰符和 Java 程序性能优化没有必然联系

###  抽象类和接口的区别是什么

抽象类和接口都是 Java 中的关键字，抽象类和接口中都允许进行方法的定义，而不用具体的方法实现。抽象类和接口都允许被继承，它们广泛的应用于 JDK 和框架的源码中，来实现多态和不同的设计模式。

不同点在于

抽象级别不同：类、抽象类、接口其实是三种不同的抽象级别，抽象程度依次是 接口 > 抽象类 > 类。在接口中，只允许进行方法的定义，不允许有方法的实现，抽象类中可以进行方法的定义和实现；而类中只允许进行方法的实现，我说的方法的定义是不允许在方法后面出现 {}
使用的关键字不同：类使用 class 来表示；抽象类使用 abstract class 来表示；接口使用 interface 来表示
变量：接口中定义的变量只能是公共的静态常量，抽象类中的变量是普通变量。

###  2021/3/24  byte的取值范围是多少，怎么计算出来的

byte 的取值范围是 -128 -> 127 之间，一共是 256 。一个 byte 类型在计算机中占据一个字节，那么就是 8 bit，所以最大就是 2^7 = 1111 1111。

Java 中用补码来表示二进制数，补码的最高位是符号位，最高位用 0 表示正数，最高位 1 表示负数，正数的补码就是其本身，由于最高位是符号位，所以正数表示的就是 0111 1111 ，也就是 127。最大负数就是 1111 1111，这其中会涉及到两个 0 ，一个 +0 ，一个 -0 ，+0 归为正数，也就是 0 ，-0 归为负数，也就是 -128，所以 byte 的范围就是 -128 - 127。

###  HashMap 和HashTable的区别

**相同点**：HashMap 和 HashTable 都是基于哈希表实现的，其内部每个元素都是 key-value 键值对，HashMap 和 HashTable 都实现了 Map、Cloneable、Serializable 接口。

**不同点**：

- 父类不同：HashMap 继承了 AbstractMap 类，而 HashTable 继承了 Dictionary 类
- 空值不同：HashMap 允许空的 key 和 value 值，HashTable 不允许空的 key 和 value 值。HashMap 会把 Null key 当做普通的 key 对待。不允许 null key 重复。
- 线程安全性：HashMap 不是线程安全的，如果多个外部操作同时修改 HashMap 的数据结构比如 add 或者是 delete，必须进行同步操作，仅仅对 key 或者 value 的修改不是改变数据结构的操作。可以选择构造线程安全的 Map 比如 Collections.synchronizedMap 或者是 ConcurrentHashMap。而 HashTable 本身就是线程安全的容器。
- 性能方面：虽然 HashMap 和 HashTable 都是基于单链表的，但是 HashMap 进行 put 或者 get􏱤 操作，可以达到常数时间的性能；而 HashTable 的 put 和 get 操作都是加了 synchronized 锁的，所以效率很差。
-  初始容量不同：HashTable 的初始长度是11，之后每次扩充容量变为之前的 2n+1（n为上一次的长度）而 HashMap 的初始长度为16，之后每次扩充变为原来的两倍。创建时，如果给定了容量初始值，那么HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小 



### 2021/3/25 HashMap 的底层结构

![1616685915417](每天一积累.assets/1616685915417.png)

![1616685923525](每天一积累.assets/1616685923525.png)

**HashMap 的长度为什么是 2 的幂次方**

![1616687275307](每天一积累.assets/1616687275307.png)

###  UTF-8 和 Unicode 的关系

![1616687645402](每天一积累.assets/1616687645402.png)

###  项目为 UTF-8 环境，char c = '中'，是否合法

可以，因为 Unicode 编码采用 2 个字节的编码，UTF-8 是 Unicode 的一种实现，它使用可变长度的字符集进行编码，char c = '中' 是两个字节，所以能够存储。合法。

